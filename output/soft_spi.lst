C51 COMPILER V9.60.0.0   SOFT_SPI                                                          11/06/2021 22:12:00 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE SOFT_SPI
OBJECT MODULE PLACED IN .\output\soft_spi.obj
COMPILER INVOKED BY: C:\Keil_v5_c51\C51\BIN\C51.EXE ECBM_LIB\soft_spi.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\ECBM_LIB
                    -;.\device;.\device\new_test;.\device\proj) DEBUG OBJECTEXTEND PRINT(.\output\soft_spi.lst) OBJECT(.\output\soft_spi.obj)

line level    source

   1          #include "ecbm_core.h"//统一加载核心头文件
   2          #if ECBM_SOFTSPI_LIB_EN//检查本库有没有被使能
   3          u8 idata soft_spi_def_clk_port;
   4          u8 idata soft_spi_def_clk_pin;
   5          u8 idata soft_spi_def_mosi_port;
   6          u8 idata soft_spi_def_mosi_pin;
   7          u8 idata soft_spi_def_miso_port;
   8          u8 idata soft_spi_def_miso_pin;
   9          u8 idata soft_spi_def_cs_port;
  10          u8 idata soft_spi_def_cs_pin;
  11          u8 idata soft_spi_mode=0;
  12          u8 xdata soft_spi_index=0;
  13          u8 xdata soft_spi_max=0;
  14          /*-------------------------------------------------------
  15          软件SPI引脚切换函数。
  16          -------------------------------------------------------*/
  17          void soft_spi_set_pin(soft_spi_def * dev){
  18   1              if(soft_spi_index!=dev->dev_id){                  //判断ID号，可以加速8us@24MHz的时间。
  19   2                      soft_spi_def_clk_port =io2port(dev->clk_pin); //解压时钟脚的P口。
  20   2                      soft_spi_def_clk_pin  =io2pin (dev->clk_pin); //解压时钟脚的IO口。
  21   2                      soft_spi_def_mosi_port=io2port(dev->mosi_pin);//解压数据输出脚的P口。
  22   2                      soft_spi_def_mosi_pin =io2pin (dev->mosi_pin);//解压数据输出脚的IO口。
  23   2                      soft_spi_def_miso_port=io2port(dev->miso_pin);//解压数据输入脚的P口。
  24   2                      soft_spi_def_miso_pin =io2pin (dev->miso_pin);//解压数据输入脚的IO口。
  25   2                      soft_spi_def_cs_port  =io2port(dev->cs_pin);  //解压片选脚的P口。
  26   2                      soft_spi_def_cs_pin   =io2pin (dev->cs_pin);  //解压片选脚的IO口。
  27   2                      soft_spi_mode=dev->mode;                      //设置模式。
  28   2                      soft_spi_index=dev->dev_id;                   //切换ID。
  29   2              }       
  30   1      }
  31          /*-------------------------------------------------------
  32          软件SPI初始化函数。
  33          -------------------------------------------------------*/
  34          void soft_spi_init(soft_spi_def * dev,u8 clk,u8 mosi,u8 miso,u8 cs,u8 mode){
  35   1              dev->clk_pin =clk;             //保存时钟脚信息。
  36   1              dev->mosi_pin=mosi;            //保存数据输出脚信息。
  37   1              dev->miso_pin=miso;            //保存数据输入脚信息。
  38   1              dev->cs_pin  =cs;              //保存片选脚信息。
  39   1              dev->mode    =mode;            //保存模式信息。
  40   1              gpio_mode(clk, GPIO_OUT);      //时钟脚设置为推挽。
  41   1              if(mode&SOFT_SPI_CPOL_MASK){   //查看时钟极性设置，
  42   2                      gpio_out(clk,1);           //极性是高电平就先置高，
  43   2              }else{
  44   2                      gpio_out(clk,0);           //极性是低电平就先置低。
  45   2              }
  46   1              if(mode&SOFT_SPI_MOSI_EN_MASK){//查看MOSI使能，
  47   2                      gpio_mode(mosi,GPIO_OUT);  //使能了就设置为推挽模式。
  48   2                      gpio_out (mosi,1);         //默认高电平。
  49   2              }
  50   1              if(mode&SOFT_SPI_MISO_EN_MASK){//查看MISO使能，
  51   2                      gpio_mode  (miso,GPIO_IN); //使能了就设置为弱上拉模式。
  52   2                      gpio_out   (miso,1);       //默认高电平。
  53   2              }
  54   1              if(mode&SOFT_SPI_CS_EN_MASK){  //查看片选脚使能，
C51 COMPILER V9.60.0.0   SOFT_SPI                                                          11/06/2021 22:12:00 PAGE 2   

  55   2                      gpio_mode(cs,GPIO_OUT);    //使能了就设置为推挽模式。
  56   2                      gpio_out (cs,1);           //默认高电平。
  57   2              }
  58   1              dev->dev_id=++soft_spi_max;    //获取ID号。
  59   1              soft_spi_set_pin(dev);         //设置参数到系统。
  60   1      } 
  61          /*-------------------------------------------------------
  62          软件SPI引脚切换函数（内联版）。
  63          -------------------------------------------------------*/
  64          void soft_spi_set_pin_linkage(u8 id,u8 clk,u8 mosi,u8 miso,u8 cs,u8 mode){
  65   1              if(soft_spi_index!=id){                    //判断ID号，可以加速8us@24MHz的时间。
  66   2                      soft_spi_def_clk_port =io2port(clk);   //解压时钟脚的P口。
  67   2                      soft_spi_def_clk_pin  =io2pin (clk);   //解压时钟脚的IO口。
  68   2                      soft_spi_def_mosi_port=io2port(mosi);  //解压数据输出脚的P口。
  69   2                      soft_spi_def_mosi_pin =io2pin (mosi);  //解压数据输出脚的IO口。
  70   2                      soft_spi_def_miso_port=io2port(miso);  //解压数据输入脚的P口。
  71   2                      soft_spi_def_miso_pin =io2pin (miso);  //解压数据输入脚的IO口。
  72   2                      soft_spi_def_cs_port  =io2port(cs);    //解压片选脚的P口。
  73   2                      soft_spi_def_cs_pin   =io2pin (cs);    //解压片选脚的IO口。
  74   2                      soft_spi_mode=mode;                    //设置模式。
  75   2                      soft_spi_index=id;                     //切换ID。
  76   2              }       
  77   1      }
  78          /*-------------------------------------------------------
  79          软件SPI初始化函数（内联版）。
  80          -------------------------------------------------------*/
  81          u8 soft_spi_init_linkage(u8 clk,u8 mosi,u8 miso,u8 cs,u8 mode){
  82   1              u8 id;                         //唯一ID号
  83   1              gpio_mode(clk, GPIO_OUT);      //时钟脚设置为推挽。
  84   1              if(mode&SOFT_SPI_CPOL_MASK){   //查看时钟极性设置，
  85   2                      gpio_out(clk,1);           //极性是高电平就先置高，
  86   2              }else{
  87   2                      gpio_out(clk,0);           //极性是低电平就先置低。
  88   2              }
  89   1              if(mode&SOFT_SPI_MOSI_EN_MASK){//查看MOSI使能，
  90   2                      gpio_mode(mosi,GPIO_OUT);  //使能了就设置为推挽模式。
  91   2                      gpio_out (mosi,1);         //默认高电平。
  92   2              }
  93   1              if(mode&SOFT_SPI_MISO_EN_MASK){//查看MISO使能，
  94   2                      gpio_mode  (miso,GPIO_IN); //使能了就设置为弱上拉模式。
  95   2                      gpio_out   (miso,1);       //默认高电平。
  96   2              }
  97   1              if(mode&SOFT_SPI_CS_EN_MASK){  //查看片选脚使能，
  98   2                      gpio_mode(cs,GPIO_OUT);    //使能了就设置为推挽模式。
  99   2                      gpio_out (cs,1);           //默认高电平。
 100   2              }
 101   1              id =++soft_spi_max;            //获取ID号。
 102   1              soft_spi_set_pin_linkage(id,clk,mosi,miso,cs,mode);//设置参数到系统。
 103   1              return id;                         //返回ID号。
 104   1      } 
 105          /*-------------------------------------------------------
 106          软件SPI发送/接收函数。
 107          -------------------------------------------------------*/
 108          u8 soft_spi_send(u8 dat){
 109   1              u8 i,j,k=0;
 110   1              if(soft_spi_mode&SOFT_SPI_CPOL_MASK){                           //读取时钟极性参数。
 111   2                      gpio_out_fast(soft_spi_def_clk_port,soft_spi_def_clk_pin,1);//根据参数设置一下IO的初始状态。
 112   2              }else{
 113   2                      gpio_out_fast(soft_spi_def_clk_port,soft_spi_def_clk_pin,0);//目的是为了防止多引脚复用下的电平错位。
 114   2              }
 115   1              if((soft_spi_mode&(SOFT_SPI_CS_CON_MASK|SOFT_SPI_CS_EN_MASK))==(SOFT_SPI_CS_CON_MASK|SOFT_SPI_CS_EN_MASK)
             -){
C51 COMPILER V9.60.0.0   SOFT_SPI                                                          11/06/2021 22:12:00 PAGE 3   

 116   2                      gpio_out_fast(soft_spi_def_cs_port,soft_spi_def_cs_pin,0);//如果片选脚使能且由库函数控制，就拉低电平。
 117   2              }
 118   1              if(soft_spi_mode&SOFT_SPI_MSB_LSB_MASK){//如果是先发高位。
 119   2                      i=0x80;
 120   2                      for(j=0;j<8;j++){                   //8位的数据。
 121   3                              if(dat&i){                      //根据当前位决定输出电平。
 122   4                                      gpio_out_fast(soft_spi_def_mosi_port,soft_spi_def_mosi_pin,1);
 123   4                              }else{
 124   4                                      gpio_out_fast(soft_spi_def_mosi_port,soft_spi_def_mosi_pin,0);
 125   4                              }
 126   3                              gpio_toggle_fast(soft_spi_def_clk_port,soft_spi_def_clk_pin);//时钟脚第一次翻转。
 127   3                              if((soft_spi_mode&SOFT_SPI_MISO_EN_MASK)&&((soft_spi_mode&SOFT_SPI_CPHA_MASK)==0)){//读取时钟相位设置。
 128   4                                      if(gpio_in_fast(soft_spi_def_miso_port,soft_spi_def_miso_pin)){//设置是第一次翻转读的话，就读MISO脚。
 129   5                                              k|=i;//将MISO脚的数据存入临时变量里。
 130   5                                      }
 131   4                              }
 132   3                              gpio_toggle_fast(soft_spi_def_clk_port,soft_spi_def_clk_pin);//时钟脚第二次翻转。
 133   3                              if((soft_spi_mode&SOFT_SPI_MISO_EN_MASK)&&((soft_spi_mode&SOFT_SPI_CPHA_MASK)==1)){//读取时钟相位设置。
 134   4                                      if(gpio_in_fast(soft_spi_def_miso_port,soft_spi_def_miso_pin)){//设置是第二次翻转读的话，就读MISO脚。
 135   5                                              k|=i;//将MISO脚的数据存入临时变量里。
 136   5                                      }
 137   4                              }
 138   3                              i>>=1;
 139   3                      }
 140   2              }else{                                  //如果是先发低位
 141   2                      i=0x01;
 142   2                      for(j=0;j<8;j++){                  //8位的数据。
 143   3                              if(dat&i){                     //根据当前位决定输出电平。
 144   4                                      gpio_out_fast(soft_spi_def_mosi_port,soft_spi_def_mosi_pin,1);
 145   4                              }else{
 146   4                                      gpio_out_fast(soft_spi_def_mosi_port,soft_spi_def_mosi_pin,0);
 147   4                              }
 148   3                              gpio_toggle_fast(soft_spi_def_clk_port,soft_spi_def_clk_pin);//时钟脚第一次翻转。
 149   3                              if((soft_spi_mode&SOFT_SPI_MISO_EN_MASK)&&((soft_spi_mode&SOFT_SPI_CPHA_MASK)==0)){//读取时钟相位设置。
 150   4                                      if(gpio_in_fast(soft_spi_def_miso_port,soft_spi_def_miso_pin)){//设置是第一次翻转读的话，就读MISO脚。
 151   5                                              k|=i;//将MISO脚的数据存入临时变量里。
 152   5                                      }
 153   4                              }
 154   3                              gpio_toggle_fast(soft_spi_def_clk_port,soft_spi_def_clk_pin);
 155   3                              if((soft_spi_mode&SOFT_SPI_MISO_EN_MASK)&&((soft_spi_mode&SOFT_SPI_CPHA_MASK)==1)){//读取时钟相位设置。
 156   4                                      if(gpio_in_fast(soft_spi_def_miso_port,soft_spi_def_miso_pin)){//设置是第二次翻转读的话，就读MISO脚。
 157   5                                              k|=i;//将MISO脚的数据存入临时变量里。
 158   5                                      }
 159   4                              }
 160   3                              i<<=1;
 161   3                      }
 162   2              }
 163   1              if((soft_spi_mode&(SOFT_SPI_CS_CON_MASK|SOFT_SPI_CS_EN_MASK))==(SOFT_SPI_CS_CON_MASK|SOFT_SPI_CS_EN_MASK)
             -){
 164   2                      gpio_out_fast(soft_spi_def_cs_port,soft_spi_def_cs_pin,1);//如果片选脚使能且由库函数控制，就拉高电平。
 165   2              }
 166   1              return k;//返回缓存值。
 167   1      }
 168          #endif  //和最上面的#ifndef配合成一个程序段。
 169                  //以一个空行为结尾。


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1105    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      2      23
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.60.0.0   SOFT_SPI                                                          11/06/2021 22:12:00 PAGE 4   

   DATA SIZE        =   ----    ----
   IDATA SIZE       =      9    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
