C51 COMPILER V9.60.0.0   MAIN                                                              11/07/2021 22:17:17 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\output\main.obj
COMPILER INVOKED BY: C:\Keil_v5_c51\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\ECBM_LIB;.\device;.\d
                    -evice\new_test;.\device\proj) DEBUG OBJECTEXTEND PRINT(.\output\main.lst) OBJECT(.\output\main.obj)

line level    source

   1          #include "ecbm_core.h"  //加载库函数的头文件。
   2          #include "string.h"
   3          #include "ringq.h"
   4          #include "ds1302.h"
   5          #include <stdlib.h>
   6          
   7          unsigned char line1[128]= {0};
   8          unsigned char line2[128]= {0};
   9          
  10          unsigned char flag = 0;
  11          unsigned char flag2 = 0 ;
  12          QUEUE queue1,*ptrqueue1;
  13          QUEUE queue2,*ptrqueue2;
  14          int i = 0 ;
  15          
  16          unsigned char  find_string(unsigned char *line, char* p)
  17          {
  18   1          if(strstr(line,p)!=NULL)
  19   1          {
  20   2              return 1;
  21   2          }
  22   1          else
  23   1          {
  24   2              return 0;
  25   2          }
  26   1      }
  27          
  28          /* 功  能：将str字符串中的oldstr字符串替换为newstr字符串
  29           * 参  数：str：操作目标 oldstr：被替换者 newstr：替换者
  30           * 返回值：返回替换之后的字符串
  31           * 版  本： V0.2
  32           */
  33          char *strrpc(char *str,char *oldstr,char *newstr) {
  34   1          char bstr[32];//转换缓冲区
  35   1          unsigned char i = 0 ;
  36   1          memset(bstr,0,sizeof(bstr));
  37   1      
  38   1          for(i = 0; i < strlen(str); i++) {
  39   2              if(!strncmp(str+i,oldstr,strlen(oldstr))) { //查找目标字符串
  40   3                  strcat(bstr,newstr);
  41   3                  i += strlen(oldstr) - 1;
  42   3              } else {
  43   3                  strncat(bstr,str + i,1);//保存一字节进缓冲区
  44   3              }
  45   2          }
  46   1      
  47   1          strcpy(str,bstr);
  48   1          return str;
  49   1      }
  50          char *SubString(char *p,char *dst,index)
  51          {
  52   1          char bstr[32];
  53   1          char i = 0 ;
  54   1          memset(bstr,0,sizeof(bstr));
C51 COMPILER V9.60.0.0   MAIN                                                              11/07/2021 22:17:17 PAGE 2   

  55   1      
  56   1          for(i = index ; i < strlen(p); i++)
  57   1          {
  58   2              bstr[i-index] = *(p+i);
  59   2          }
  60   1      
  61   1          strcpy(dst,bstr);
  62   1          return dst;
  63   1      
  64   1      
  65   1      }
  66          
  67          unsigned char ESP8266_send_cmd(char *b,char *a,unsigned char times,unsigned int wait_time)
  68          {
  69   1          unsigned char  i=0;
  70   1          while(i < times)
  71   1          {
  72   2              uart_printf(2,b);
  73   2              uart_printf(2,"\r\n");           // 回车换行
  74   2      
  75   2              delay_ms(wait_time);
  76   2              Get_Line(ptrqueue2,line2);
  77   2              if(find_string(line2,a))
  78   2              {
  79   3                  return 1;
  80   3              }
  81   2              i++;
  82   2          }
  83   1          return 0;
  84   1      }
  85          unsigned int tick =0,tickflag=0;
  86          void fun1(void)TIMER0_IT_NUM{//这是定时器0的中断处理函数。10ms
  87   1      
  88   1          tick++;
  89   1              if(tick%100==0)
  90   1              {
  91   2                      tickflag=1;
  92   2              }
  93   1      
  94   1      
  95   1      
  96   1      
  97   1      }
  98          void main() {                   //main函数，必须的。
  99   1          int times = 0 ;
 100   1          int len = 0 ;
 101   1          unsigned char time[2]= {0};
 102   1      
 103   1          system_init();              //系统初始化函数，也是必须的。
 104   1          timer_init();
 105   1          timer_start(0);//再打开定时器0。
 106   1              timer_set_timer_mode(0,10000);
 107   1          DS1302_Initial();
 108   1      
 109   1          //两个串口的环形队列初始化
 110   1          ptrqueue1 = &queue1;
 111   1          ptrqueue2 = &queue2;
 112   1          initQueue(ptrqueue1);
 113   1          initQueue(ptrqueue2);
 114   1      
 115   1          uart_printf(1,"starting..\r\n");
 116   1          uart_set_baud(2,115200);
C51 COMPILER V9.60.0.0   MAIN                                                              11/07/2021 22:17:17 PAGE 3   

 117   1          delay_ms(3000);
 118   1          while(Get_Line(ptrqueue2,line2));//清除UART2的缓冲区
 119   1          memset(line2,0,BUF_SIZE);
 120   1      
 121   1      
 122   1      
 123   1          if(ESP8266_send_cmd("AT+CIPSNTPCFG=1,8","OK",3,300))
 124   1          {
 125   2              uart_printf(1,"send command AT+CIPSNTPCFG=1,8  OK\r\n");
 126   2          }
 127   1          else
 128   1          {
 129   2              uart_printf(1,"send command AT+CIPSNTPCFG=1,8 failed\r\n");
 130   2          }
 131   1              
 132   1              delay_ms(500);
 133   1          uart_printf(2,"AT+CIPSNTPTIME?\r\n");
 134   1         
 135   1      
 136   1      
 137   1          while(1)
 138   1          {
 139   2      
 140   2              if(tickflag) //1s时间到
 141   2              {
 142   3                              tickflag=0;
 143   3                              DS1302_GetTime(now);
 144   3                  uart_printf(1,"%bd: %bd: %bd\r\n",now[2],now[1],now[0]);
 145   3              }
 146   2      
 147   2              if(flag>0)
 148   2              {
 149   3                  flag-=1;
 150   3                  uart_printf(1,"uart1  %bd received:",flag);
 151   3      
 152   3                  Get_Line(ptrqueue1,line1);
 153   3                  uart_printf(2,line1);
 154   3      
 155   3                  memset(line1,0,BUF_SIZE);
 156   3              }
 157   2              if(flag2>0)
 158   2              {
 159   3                  flag2-=1;
 160   3                  Get_Line(ptrqueue2,line2);
 161   3                  uart_string(1,line2);
 162   3      
 163   3                  if(find_string(line2,"+CIPSNTPTIME:"))
 164   3                  {
 165   4                      uart_printf(1,"time:");
 166   4                      uart_printf(1,line2);
 167   4                      len = strlen(line2);
 168   4                      time[0]=line2[len-9];
 169   4                      time[1]=line2[len-8];
 170   4                                      init[0] = atoi(time);
 171   4                                      
 172   4                      time[0]=line2[len-12];
 173   4                      time[1]=line2[len-11];
 174   4                                      init[1] = atoi(time);
 175   4                                      
 176   4                      time[0]=line2[len-15];
 177   4                      time[1]=line2[len-14];
 178   4                                      init[2] = atoi(time);
C51 COMPILER V9.60.0.0   MAIN                                                              11/07/2021 22:17:17 PAGE 4   

 179   4                                      
 180   4                                      init[3] = 1;init[4] = 1,init[5] = 1,init[6]=21;
 181   4                                      
 182   4                      DS1302_SetTime(init);
 183   4                                      uart_printf(1,"set time ok\r\n");
 184   4                                      
 185   4                                      //秒    分    时    日    月  星期    年
 186   4                                      //extern BYTE data init[7] ;
 187   4                                      
 188   4                                      
 189   4                     // uart_printf(1,"%s\r\n",time);
 190   4                     // uart_printf(1,"-------\r\n");
 191   4                  }
 192   3      
 193   3                  memset(line2,0,BUF_SIZE);
 194   3              }
 195   2      
 196   2      
 197   2          }
 198   1      }
 199          unsigned char temp1 = 0 ;
 200          void uart1_receive_callback(void)
 201          {
 202   1          temp1 = SBUF;
 203   1          In_Queue(ptrqueue1,temp1);
 204   1      
 205   1          if(temp1 == '\n')
 206   1          {
 207   2              flag++;
 208   2          }
 209   1      }
 210          unsigned char temp2=0;
 211          void uart2_receive_callback(void)
 212          {
 213   1          temp2 = S2BUF;
 214   1          In_Queue(ptrqueue2,temp2);
 215   1      
 216   1          if(temp2 == '\n')
 217   1          {
 218   2              flag2++;
 219   2          }
 220   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1513    ----
   CONSTANT SIZE    =    205    ----
   XDATA SIZE       =    536     105
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
