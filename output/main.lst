C51 COMPILER V9.60.0.0   MAIN                                                              11/07/2021 09:17:10 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\output\main.obj
COMPILER INVOKED BY: C:\Keil_v5_c51\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\ECBM_LIB;.\device;.\d
                    -evice\new_test;.\device\proj) DEBUG OBJECTEXTEND PRINT(.\output\main.lst) OBJECT(.\output\main.obj)

line level    source

   1          #include "ecbm_core.h"  //加载库函数的头文件。
   2          #include "string.h"
   3          #include "ringq.h"
   4          #include "ds1302.h"
   5          unsigned char line1[128]= {0};
   6          unsigned char line2[128]= {0};
   7          
   8          unsigned char flag = 0;
   9          unsigned char flag2 = 0 ;
  10          QUEUE queue1,*ptrqueue1;
  11          QUEUE queue2,*ptrqueue2;
  12          int i = 0 ;
  13          
  14          unsigned char  find_string(unsigned char *line, char* p)
  15          {
  16   1          if(strstr(line,p)!=NULL)
  17   1          {
  18   2              return 1;
  19   2          }
  20   1          else
  21   1          {
  22   2              return 0;
  23   2          }
  24   1      }
  25          
  26          /* 功  能：将str字符串中的oldstr字符串替换为newstr字符串
  27           * 参  数：str：操作目标 oldstr：被替换者 newstr：替换者
  28           * 返回值：返回替换之后的字符串
  29           * 版  本： V0.2
  30           */
  31          char *strrpc(char *str,char *oldstr,char *newstr) {
  32   1          char bstr[32];//转换缓冲区
  33   1          unsigned char i = 0 ;
  34   1          memset(bstr,0,sizeof(bstr));
  35   1      
  36   1          for(i = 0; i < strlen(str); i++) {
  37   2              if(!strncmp(str+i,oldstr,strlen(oldstr))) { //查找目标字符串
  38   3                  strcat(bstr,newstr);
  39   3                  i += strlen(oldstr) - 1;
  40   3              } else {
  41   3                  strncat(bstr,str + i,1);//保存一字节进缓冲区
  42   3              }
  43   2          }
  44   1      
  45   1          strcpy(str,bstr);
  46   1          return str;
  47   1      }
  48          char *SubString(char *p,char *dst,index)
  49          {
  50   1          char bstr[32];
  51   1          char i = 0 ;
  52   1          memset(bstr,0,sizeof(bstr));
  53   1      
  54   1          for(i = index ; i < strlen(p); i++)
C51 COMPILER V9.60.0.0   MAIN                                                              11/07/2021 09:17:10 PAGE 2   

  55   1          {
  56   2              bstr[i-index] = *(p+i);
  57   2          }
  58   1      
  59   1          strcpy(dst,bstr);
  60   1          return dst;
  61   1      
  62   1      
  63   1      }
  64          
  65          unsigned char ESP8266_send_cmd(char *b,char *a,unsigned char times,unsigned int wait_time)
  66          {
  67   1          unsigned char  i=0;
  68   1          while(i < times)
  69   1          {
  70   2              uart_printf(2,b);
  71   2              uart_printf(2,"\r\n");           // 回车换行
  72   2      
  73   2                      uart_printf(1,"send cmd 1------------\r\n");
  74   2              delay_ms(wait_time);
  75   2                      uart_printf(1,"send cmd 2------------\r\n");
  76   2              //      printf("Received data:%s\n",bc35_buf);
  77   2              Get_Line(ptrqueue2,line2);
  78   2                                      uart_printf(1,"send cmd 3------------\r\n");
  79   2              if(find_string(line2,a))
  80   2              {
  81   3                  uart_printf(1,"6.....\r\n");
  82   3                  return 1;
  83   3              }
  84   2              uart_printf(1,"7.....\r\n");
  85   2              i++;
  86   2          }
  87   1          uart_printf(1,"8.....\r\n");
  88   1          return 0;
  89   1      }
  90          
  91          void main() {                   //main函数，必须的。
  92   1          int times = 0 ;
  93   1          system_init();              //系统初始化函数，也是必须的。
  94   1      
  95   1          //两个串口的环形队列初始化
  96   1          ptrqueue1 = &queue1;
  97   1          ptrqueue2 = &queue2;
  98   1          initQueue(ptrqueue1);
  99   1          initQueue(ptrqueue2);
 100   1      
 101   1          uart_printf(1,"starting..\r\n");
 102   1          uart_set_baud(2,115200);
 103   1      
 104   1          delay_ms(3000);
 105   1          while(Get_Line(ptrqueue2,line2));//清除UART2的缓冲区
 106   1          memset(line2,0,BUF_SIZE);
 107   1      
 108   1              
 109   1              
 110   1              if(ESP8266_send_cmd("AT+CIPSNTPCFG=1,8","OK",3,300))
 111   1              {
 112   2                      uart_printf(1,"send command AT+CIPSNTPCFG=1,8  OK\r\n");
 113   2              }
 114   1              else
 115   1              {
 116   2                      uart_printf(1,"send command AT+CIPSNTPCFG=1,8 failed\r\n");
C51 COMPILER V9.60.0.0   MAIN                                                              11/07/2021 09:17:10 PAGE 3   

 117   2              }
 118   1          
 119   1      
 120   1      
 121   1          while(1)
 122   1          {
 123   2      
 124   2      
 125   2              if(flag>0)
 126   2              {
 127   3                  flag-=1;
 128   3                  uart_printf(1,"uart1  %bd received:",flag);
 129   3      
 130   3                  Get_Line(ptrqueue1,line1);
 131   3                  uart_printf(1,line1);
 132   3      
 133   3                  uart_printf(2,line1);
 134   3                  uart_printf(2,"\r\n");
 135   3                  memset(line1,0,BUF_SIZE);
 136   3              }
 137   2              if(flag2>0)
 138   2              {
 139   3                  flag2-=1;
 140   3                  Get_Line(ptrqueue2,line2);
 141   3                  uart_string(1,line2);
 142   3      
 143   3                  if(find_string(line2,"+CIPSNTPTIME:"))
 144   3                  {
 145   4                      uart_printf(1,"time:");
 146   4                      uart_printf(1,line2);
 147   4                  }
 148   3      
 149   3                  memset(line2,0,BUF_SIZE);
 150   3              }
 151   2      
 152   2      
 153   2          }
 154   1      }
 155          unsigned char temp1 = 0 ;
 156          void uart1_receive_callback(void)
 157          {
 158   1          temp1 = SBUF;
 159   1          In_Queue(ptrqueue1,temp1);
 160   1      
 161   1          if(temp1 == '\n')
 162   1          {
 163   2              flag++;
 164   2          }
 165   1      }
 166          unsigned char temp2=0;
 167          void uart2_receive_callback(void)
 168          {
 169   1          temp2 = S2BUF;
 170   1          In_Queue(ptrqueue2,temp2);
 171   1      
 172   1          if(temp2 == '\n')
 173   1          {
 174   2              flag2++;
 175   2          }
 176   1      }


C51 COMPILER V9.60.0.0   MAIN                                                              11/07/2021 09:17:10 PAGE 4   

MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1212    ----
   CONSTANT SIZE    =    257    ----
   XDATA SIZE       =    532     101
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
