C51 COMPILER V9.60.0.0   MAIN                                                              11/08/2021 18:16:36 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\output\main.obj
COMPILER INVOKED BY: C:\Keil_v5_c51\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE INCDIR(.\ECBM_LIB;.\device;.\d
                    -evice\new_test;.\device\proj) DEBUG OBJECTEXTEND PRINT(.\output\main.lst) OBJECT(.\output\main.obj)

line level    source

   1          #include "ecbm_core.h"  //加载库函数的头文件。
   2          #include "string.h"
   3          #include "ringq.h"
   4          #include "ds1302.h"
   5          #include <stdlib.h>
   6          
   7          #define  FUYAOSHIJIAN 7
   8          #define DUISHISHIJIAN 8
   9          #define QINGSHUJUSHIJIAN 0
  10          
  11          sbit BEEP= P3^7;
  12          unsigned char line1[128]= {0};
  13          unsigned char line2[128]= {0};
  14          
  15          unsigned char flag = 0;
  16          unsigned char flag2 = 0 ;
  17          QUEUE queue1,*ptrqueue1;
  18          QUEUE queue2,*ptrqueue2;
  19          int i = 0 ;
  20          
  21          unsigned char  find_string(unsigned char *line, char* p)
  22          {
  23   1          if(strstr(line,p)!=NULL)
  24   1          {
  25   2              return 1;
  26   2          }
  27   1          else
  28   1          {
  29   2              return 0;
  30   2          }
  31   1      }
  32          
  33          /* 功  能：将str字符串中的oldstr字符串替换为newstr字符串
  34           * 参  数：str：操作目标 oldstr：被替换者 newstr：替换者
  35           * 返回值：返回替换之后的字符串
  36           * 版  本： V0.2
  37           */
  38          char *strrpc(char *str,char *oldstr,char *newstr) {
  39   1          char bstr[32];//转换缓冲区
  40   1          unsigned char i = 0 ;
  41   1          memset(bstr,0,sizeof(bstr));
  42   1      
  43   1          for(i = 0; i < strlen(str); i++) {
  44   2              if(!strncmp(str+i,oldstr,strlen(oldstr))) { //查找目标字符串
  45   3                  strcat(bstr,newstr);
  46   3                  i += strlen(oldstr) - 1;
  47   3              } else {
  48   3                  strncat(bstr,str + i,1);//保存一字节进缓冲区
  49   3              }
  50   2          }
  51   1      
  52   1          strcpy(str,bstr);
  53   1          return str;
  54   1      }
C51 COMPILER V9.60.0.0   MAIN                                                              11/08/2021 18:16:36 PAGE 2   

  55          char *SubString(char *p,char *dst,index)
  56          {
  57   1          char bstr[32];
  58   1          char i = 0 ;
  59   1          memset(bstr,0,sizeof(bstr));
  60   1      
  61   1          for(i = index ; i < strlen(p); i++)
  62   1          {
  63   2              bstr[i-index] = *(p+i);
  64   2          }
  65   1      
  66   1          strcpy(dst,bstr);
  67   1          return dst;
  68   1      
  69   1      
  70   1      }
  71          
  72          unsigned char ESP8266_send_cmd(char *b,char *a,unsigned char times,unsigned int wait_time)
  73          {
  74   1          unsigned char  i=0;
  75   1          while(i < times)
  76   1          {
  77   2              uart_printf(2,b);
  78   2              uart_printf(2,"\r\n");           // 回车换行
  79   2      
  80   2              delay_ms(wait_time);
  81   2              Get_Line(ptrqueue2,line2);
  82   2              if(find_string(line2,a))
  83   2              {
  84   3                  return 1;
  85   3              }
  86   2              i++;
  87   2          }
  88   1          return 0;
  89   1      }
  90          unsigned int tick =0,tickflag=0;
  91          void fun1(void)TIMER0_IT_NUM{//这是定时器0的中断处理函数。10ms
  92   1      
  93   1          tick++;
  94   1          if(tick%100==0)
  95   1          {
  96   2              tickflag=1;
  97   2          }
  98   1      
  99   1      
 100   1      
 101   1      
 102   1      }
 103          void main() {                   //main函数，必须的。
 104   1              
 105   1          int times = 0 ;
 106   1          int len = 0 ;
 107   1          bit    yifuyao=0;
 108   1          bit    yiduishi=0;
 109   1          unsigned char time[2]= {0};
 110   1              unsigned char  volatile beep = 0;
 111   1          system_init();              //系统初始化函数，也是必须的。
 112   1          timer_init();
 113   1          timer_start(0);//再打开定时器0。
 114   1          timer_set_timer_mode(0,10000);
 115   1          DS1302_Initial();
 116   1      
C51 COMPILER V9.60.0.0   MAIN                                                              11/08/2021 18:16:36 PAGE 3   

 117   1          //两个串口的环形队列初始化
 118   1          ptrqueue1 = &queue1;
 119   1          ptrqueue2 = &queue2;
 120   1          initQueue(ptrqueue1);
 121   1          initQueue(ptrqueue2);
 122   1      
 123   1          uart_printf(1,"starting..\r\n");
 124   1          uart_set_baud(2,115200);
 125   1          delay_ms(3000);
 126   1          while(Get_Line(ptrqueue2,line2));//清除UART2的缓冲区
 127   1          memset(line2,0,BUF_SIZE);
 128   1      
 129   1      
 130   1      
 131   1          if(ESP8266_send_cmd("AT+CIPSNTPCFG=1,8","OK",3,300))
 132   1          {
 133   2              uart_printf(1,"send command AT+CIPSNTPCFG=1,8  OK\r\n");
 134   2          }
 135   1          else
 136   1          {
 137   2              uart_printf(1,"send command AT+CIPSNTPCFG=1,8 failed\r\n");
 138   2          }
 139   1      
 140   1          delay_ms(1000);
 141   1          uart_printf(2,"AT+CIPSNTPTIME?\r\n");
 142   1      
 143   1      
 144   1      
 145   1          while(1)
 146   1          {
 147   2      
 148   2              if(tickflag) //1s时间到
 149   2              {
 150   3                  tickflag=0;
 151   3                  DS1302_GetTime(now);
 152   3                  uart_printf(1,"%bd: %bd: %bd\r\n",now[2],now[1],now[0]);
 153   3      
 154   3                  if(now[2] == DUISHISHIJIAN && now[1] ==1 && now[0] == 1 && yiduishi == 0)  // 8：1:1时，连接服
             -器器对时
 155   3                  {
 156   4                      uart_printf(2,"AT+CIPSNTPTIME?\r\n");
 157   4                      yiduishi = 1;
 158   4                  }
 159   3                  if(now[2] == QINGSHUJUSHIJIAN && now[1] == 1&& now[0] == 0)//0：1：0时清fifuyao和yiduishi
 160   3                  {
 161   4                      yifuyao=0;
 162   4                      yiduishi=0;
 163   4                  }
 164   3                  if(now[2] == FUYAOSHIJIAN)
 165   3                  {
 166   4                      if(yifuyao==0)
 167   4                      {
 168   5                          beep = 1;
 169   5                          //判断是否已取瓶，已取瓶就将yifuyao置1
 170   5                          P24 = 0 ;
 171   5      
 172   5                          delay_ms(1);
 173   5                          if(P32 == 1)
 174   5                          {
 175   6                              delay_ms(20);
 176   6                              if(P32 == 1)
 177   6                              {
C51 COMPILER V9.60.0.0   MAIN                                                              11/08/2021 18:16:36 PAGE 4   

 178   7                                  _nop_();
 179   7                                  yifuyao = 1;
 180   7                              }
 181   6                          }
 182   5                          P24 = 1 ;
 183   5      
 184   5                      }
 185   4                      else beep = 0;
 186   4                  }
 187   3                              if(beep)
 188   3                              {
 189   4                                      BEEP= !BEEP;
 190   4                              }
 191   3                              else BEEP = 0 ;
 192   3      
 193   3              }
 194   2              //以下是串口处理程序
 195   2              if(flag>0)
 196   2              {
 197   3                  flag-=1;
 198   3                  uart_printf(1,"uart1  %bd received:",flag);
 199   3      
 200   3                  Get_Line(ptrqueue1,line1);
 201   3                  uart_printf(2,line1);
 202   3      
 203   3                  memset(line1,0,BUF_SIZE);
 204   3              }
 205   2              if(flag2>0)
 206   2              {
 207   3                  flag2-=1;
 208   3                  Get_Line(ptrqueue2,line2);
 209   3                  uart_string(1,line2);
 210   3      
 211   3                  if(find_string(line2,"+CIPSNTPTIME:"))
 212   3                  {
 213   4                      uart_printf(1,"time:");
 214   4                      uart_printf(1,line2);
 215   4                      len = strlen(line2);
 216   4                      time[0]=line2[len-9];
 217   4                      time[1]=line2[len-8];
 218   4                      init[0] = atoi(time);
 219   4      
 220   4                      time[0]=line2[len-12];
 221   4                      time[1]=line2[len-11];
 222   4                      init[1] = atoi(time);
 223   4      
 224   4                      time[0]=line2[len-15];
 225   4                      time[1]=line2[len-14];
 226   4                      init[2] = atoi(time);
 227   4      
 228   4                      init[3] = 1;
 229   4                      init[4] = 1,init[5] = 1,init[6]=21;
 230   4      
 231   4                      if(init[2] == 18)
 232   4                      {
 233   5                          if(init[0]!=0&&init[1]!=0&&init[2]!=0)
 234   5                          {
 235   6                              DS1302_SetTime(init);
 236   6                              uart_printf(1,"set time ok\r\n");
 237   6                          }
 238   5                      }
 239   4                      //秒    分    时    日    月  星期    年
C51 COMPILER V9.60.0.0   MAIN                                                              11/08/2021 18:16:36 PAGE 5   

 240   4                      //extern BYTE data init[7] ;
 241   4                  }
 242   3                  memset(line2,0,BUF_SIZE);
 243   3              }
 244   2              //以上是串口处理程序
 245   2          }
 246   1      }
 247          unsigned char temp1 = 0 ;
 248          void uart1_receive_callback(void)
 249          {
 250   1          temp1 = SBUF;
 251   1          In_Queue(ptrqueue1,temp1);
 252   1      
 253   1          if(temp1 == '\n')
 254   1          {
 255   2              flag++;
 256   2          }
 257   1      }
 258          unsigned char temp2=0;
 259          void uart2_receive_callback(void)
 260          {
 261   1          temp2 = S2BUF;
 262   1          In_Queue(ptrqueue2,temp2);
 263   1      
 264   1          if(temp2 == '\n')
 265   1          {
 266   2              flag2++;
 267   2          }
 268   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1655    ----
   CONSTANT SIZE    =    205    ----
   XDATA SIZE       =    536     106
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
